
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">mars/cmd/cli/main.go (0.0%)</option>
				
				<option value="file1">mars/internal/app/app.go (100.0%)</option>
				
				<option value="file2">mars/internal/config/config.go (0.0%)</option>
				
				<option value="file3">mars/internal/parser/parser.go (100.0%)</option>
				
				<option value="file4">mars/internal/rover/rover.go (96.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "flag"
        "fmt"
        "io"
        "log"
        "mars/internal/app"
        "mars/internal/parser"
        "mars/internal/rover"
        "os"
)

type Config struct {
        FilePath        string
        MinPlateauSizeX int
        MinPlateauSizeY int
}

func main() <span class="cov0" title="0">{
        cfg := parseFlags()

        inputReader, cleanup, err := getInputReader(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("FATAL: %v", err)
        }</span>
        <span class="cov0" title="0">defer cleanup()

        bufferedReader := bufio.NewReader(inputReader)

        if err := run(bufferedReader); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("FATAL: Application failed: %v", err)
        }</span>
}

func parseFlags() *Config <span class="cov0" title="0">{
        cfg := &amp;Config{}

        flag.StringVar(&amp;cfg.FilePath, "file", "", "Input file. If not provided, reads from stdin.")
        flag.IntVar(&amp;cfg.MinPlateauSizeX, "min-size-x", 2, "Minimum size X for plateau (optional)")
        flag.IntVar(&amp;cfg.MinPlateauSizeY, "min-size-y", 2, "Minimum size Y for plateau (optional)")

        flag.Parse()

        return cfg
}</span>

func getInputReader(cfg *Config) (io.Reader, func(), error) <span class="cov0" title="0">{
        noOpCleanup := func() </span>{<span class="cov0" title="0">}</span>

        // check to see if a FilePath has been provided
        <span class="cov0" title="0">if cfg.FilePath != "" </span><span class="cov0" title="0">{

                file, err := os.Open(cfg.FilePath)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, noOpCleanup, fmt.Errorf("could not open file: %w", err)
                }</span>
                <span class="cov0" title="0">return file, func() </span><span class="cov0" title="0">{ file.Close() }</span>, nil
        }

        // check if there is stdin data
        <span class="cov0" title="0">stat, err := os.Stdin.Stat()

        if err != nil </span><span class="cov0" title="0">{
                return nil, noOpCleanup, fmt.Errorf("could not stat stdin: %w", err)
        }</span>

        <span class="cov0" title="0">if (stat.Mode() &amp; os.ModeCharDevice) != 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "Usage: program -file &lt;path&gt; OR echo 'data' | program")
                fmt.Fprintln(os.Stderr, "Options:")
                fmt.Fprintln(os.Stderr, "  -min-size-x int  Minimum size X for plateau")
                fmt.Fprintln(os.Stderr, "  -min-size-y int  Minimum size Y for plateau")

                return nil, noOpCleanup, fmt.Errorf("no input source provided")
        }</span>

        <span class="cov0" title="0">return os.Stdin, noOpCleanup, nil</span>
}

func run(reader io.Reader) error <span class="cov0" title="0">{
        p := parser.New()
        mcf := rover.NewMissionControlFactory()

        app := app.NewApp(p, mcf, reader, os.Stdout)

        return app.Run()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "fmt"
        "io"
        "mars/internal/config"
        "mars/internal/rover"
)

type Parser interface {
        Parse(input string) (*rover.Plateau, []rover.RoverInstruction, error)
}

type App struct {
        parser Parser
        mcf    rover.MissionControlFactory
        input  io.Reader
        output io.Writer
        cfg    *config.Config
}

func NewApp(p Parser, mcf rover.MissionControlFactory, i io.Reader, o io.Writer) *App <span class="cov8" title="1">{
        return &amp;App{
                parser: p,
                mcf:    mcf,
                input:  i,
                output: o,
        }
}</span>

func (a *App) Run() error <span class="cov8" title="1">{
        inputBytes, err := io.ReadAll(a.input)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error reading input: %w", err)
        }</span>

        <span class="cov8" title="1">plateau, instructions, err := a.parser.Parse(string(inputBytes))
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error parsing input: %w", err)
        }</span>

        <span class="cov8" title="1">mc, err := a.mcf.Create(plateau)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error creating mission control: %w", err)
        }</span>

        <span class="cov8" title="1">missionControlInput := &amp;rover.MissionControlInput{
                Instructions: instructions,
        }

        output, err := mc.Execute(missionControlInput)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error executing mission: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(a.output, "info: Mission complete. Final rover positions:")
        fmt.Println()
        for _, singleRoverOutput := range output </span><span class="cov8" title="1">{
                fmt.Fprintln(a.output, singleRoverOutput)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

type Config struct {
        FilePath    string
        MinPlateauX int
        MinPlateauY int
}

func Default() Config <span class="cov0" title="0">{
        return Config{
                FilePath:    "",
                MinPlateauX: 2,
                MinPlateauY: 2,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package parser

import (
        "errors"
        "fmt"
        "mars/internal/rover"

        "strconv"
        "strings"
)

var (
        ErrParseInvalidFormat    = errors.New("must have a plateau line first and pairs of rover lines")
        ErrParsePlateauFormat    = errors.New("wrong plateau element count, must be X Y")
        ErrParsePositionFormat   = errors.New("wrong rover position element count, must be x y direction")
        ErrParsePlateauX         = errors.New("invalid plateau width")
        ErrParsePlateauY         = errors.New("invalid plateau height")
        ErrParsePositionX        = errors.New("invalid position given for X coordinate")
        ErrParsePositionY        = errors.New("invalid position given for Y coordinate")
        ErrParseInvalidDirection = errors.New("invalid direction given, must be N, E, S, W")
        ErrParseInvalidCommand   = errors.New("invalid command character given, must be L, R, M")
)

type Parser struct{}

func New() *Parser <span class="cov8" title="1">{
        return &amp;Parser{}
}</span>

func (p *Parser) Parse(input string) (*rover.Plateau, []rover.RoverInstruction, error) <span class="cov8" title="1">{
        lines := strings.Split(strings.TrimSpace(input), "\n")

        // reject inputs that are not one plateau line + n * pair of instruction lines (a pair per rover with a min of 1 pair)
        if len(lines) &lt; 3 || (len(lines)-1)%2 != 0 </span><span class="cov8" title="1">{
                return nil, nil, ErrParseInvalidFormat
        }</span>

        // parse plateau
        <span class="cov8" title="1">plateau, err := parsePlateauLine(lines[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>

        // parse rover instructions
        <span class="cov8" title="1">instructions := make([]rover.RoverInstruction, 0, (len(lines)-1)/2)
        for i := 1; i &lt; len(lines); i += 2 </span><span class="cov8" title="1">{
                positionLine := lines[i]
                commandsLine := lines[i+1]

                position, err := parsePositionLine(positionLine, plateau)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>

                <span class="cov8" title="1">cmds, err := parseCommandsLine(commandsLine)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>

                <span class="cov8" title="1">instruction := rover.RoverInstruction{
                        InitialPosition: position,
                        Commands:        cmds,
                }

                instructions = append(instructions, instruction)</span>
        }

        <span class="cov8" title="1">return plateau, instructions, nil</span>
}

// parsePlateauLine takes a string and returns a Plateau pointer or an error if the given data is not a line of pair of integers
func parsePlateauLine(line string) (*rover.Plateau, error) <span class="cov8" title="1">{
        parts := strings.Fields(strings.TrimSpace(line))

        if len(parts) != 2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: want 2 elements, got %d", ErrParsePlateauFormat, len(parts))
        }</span>

        <span class="cov8" title="1">maxX, err := strconv.Atoi(parts[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %v %v", ErrParsePlateauX, parts[0], err)
        }</span>

        <span class="cov8" title="1">maxY, err := strconv.Atoi(parts[1])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %v %v", ErrParsePlateauY, parts[1], err)
        }</span>

        <span class="cov8" title="1">return rover.NewPlateau(maxX, maxY)</span>
}

// parsePositionLine
func parsePositionLine(line string, plateau *rover.Plateau) (*rover.Position, error) <span class="cov8" title="1">{
        parts := strings.Fields(line)

        if len(parts) != 3 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: want 3 elements, got %d", ErrParsePositionFormat, len(parts))
        }</span>

        <span class="cov8" title="1">x, err := strconv.Atoi(parts[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %v", ErrParsePositionX, err)
        }</span>

        <span class="cov8" title="1">y, err := strconv.Atoi(parts[1])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %v", ErrParsePositionY, err)
        }</span>

        <span class="cov8" title="1">dir, err := parseDirection(parts[2])
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">coords := rover.NewCoordinates(x, y)
        return rover.NewPosition(plateau, coords, dir)</span>
}

// parseDirection
func parseDirection(dir string) (rover.Direction, error) <span class="cov8" title="1">{
        // make it case-insensitive as a convenience feature
        switch strings.ToUpper(strings.TrimSpace(dir)) </span>{
        case "N":<span class="cov8" title="1">
                return rover.N, nil</span>
        case "E":<span class="cov8" title="1">
                return rover.E, nil</span>
        case "S":<span class="cov8" title="1">
                return rover.S, nil</span>
        case "W":<span class="cov8" title="1">
                return rover.W, nil</span>
        }
        <span class="cov8" title="1">return rover.UnknownDirection, fmt.Errorf("%w: given %s", ErrParseInvalidDirection, dir)</span>
}

// parseCommandsLine
func parseCommandsLine(line string) (string, error) <span class="cov8" title="1">{
        // make it case-insensitive as a convenience feature
        upperLine := strings.ToUpper(strings.TrimSpace(line))

        for i, char := range upperLine </span><span class="cov8" title="1">{

                switch rover.Command(char) </span>{
                case rover.CmdLeft, rover.CmdRight, rover.CmdMove:<span class="cov8" title="1">
                        continue</span>

                default:<span class="cov8" title="1">
                        return "", fmt.Errorf("%w: character %v at position %d", ErrParseInvalidCommand, char, i)</span>
                }
        }
        <span class="cov8" title="1">return upperLine, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package rover

import (
        "errors"
        "fmt"
        "log"
)

type Direction int

var (
        ErrPositionOutOfBounds = errors.New("position must be more than 0 and within boundaries")
        ErrDirectionUnknown    = errors.New("direction must be one of N, E, S, W")
        ErrRoverPositionIsNil  = errors.New("rover must not be nil")
        ErrRoverCollision      = errors.New("path is blocked by another rover")
        ErrRoverInstructions   = errors.New("rover error executing instruction")
        ErrRoverCreating       = errors.New("rover could not be created")
        ErrPlateauTooSmall     = errors.New("plateau must be at least 2 * 2")
        ErrPlateauIsNil        = errors.New("plateau must not be nil")
)

const (
        UnknownDirection Direction = iota
        N                          // North
        E                          // East
        S                          // South
        W                          // West
)

const (
        CmdMove  Command = 'M' // Move
        CmdLeft  Command = 'L' // Left
        CmdRight Command = 'R' // Right
)

var (
        minPlateauX = 2
        minPlateauY = 2
)

type Coordinates struct {
        x int
        y int
}

type Position struct {
        coordinates Coordinates
        direction   Direction
}

type Rover struct {
        id       int
        position *Position
}

type Plateau struct {
        maxX int
        maxY int
}

type RoverInstruction struct {
        InitialPosition *Position
        Commands        string
}

type MissionControlInput struct {
        Instructions []RoverInstruction
}

type MissionControl struct {
        plateau         *Plateau
        occupiedSquares map[Coordinates]int // contains the position of an existing (not moving) rover as the key. Value is the rover ID
}

type MissionControlFactory interface {
        Create(plateau *Plateau) (*MissionControl, error)
}

type defaultMissionControlFactory struct{}

func NewMissionControlFactory() *defaultMissionControlFactory <span class="cov0" title="0">{
        return &amp;defaultMissionControlFactory{}
}</span>

func (f *defaultMissionControlFactory) Create(plateau *Plateau) (*MissionControl, error) <span class="cov0" title="0">{
        return NewMissionControl(plateau)
}</span>

// NewCoordinates takes a pair of int x, y coordinates and returns a coordinates struct and performs no validation
func NewCoordinates(x, y int) Coordinates <span class="cov8" title="1">{
        return Coordinates{
                x: x,
                y: y,
        }
}</span>

type Command rune

func (d Direction) validate() error <span class="cov8" title="1">{
        if d == UnknownDirection || d &lt; N || d &gt; W </span><span class="cov8" title="1">{
                return ErrDirectionUnknown
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NewPosition takes a plateau, coordinates and a direction and returns a pointer to a position or an error if the given arguments don't pass validation (plateau area too small or if coordinates are out of bounds)
func NewPosition(p *Plateau, c Coordinates, d Direction) (*Position, error) <span class="cov8" title="1">{
        pos := &amp;Position{
                coordinates: c,
                direction:   d,
        }

        if err := pos.validate(p); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := d.validate(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return pos, nil</span>
}

// String implements the Stringer interface
func (p *Position) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%d %d %s", p.coordinates.x, p.coordinates.y, p.direction)
}</span>

// NewRover takes an id and a Position and returns or a pointer to a Rover object or error if the given position is nil
func NewRover(id int, p *Position) (*Rover, error) <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return nil, ErrRoverPositionIsNil
        }</span>

        <span class="cov8" title="1">return &amp;Rover{
                id:       id,
                position: p,
        }, nil</span>
}

// move returns the resulting Position of applying movement to the Rover in the direction it's currently facing
func (r *Rover) move() Position <span class="cov8" title="1">{
        // we do not mutate the original
        nextPosition := *r.position
        switch r.position.direction </span>{
        case N:<span class="cov8" title="1">
                nextPosition.coordinates.y++</span>
        case E:<span class="cov8" title="1">
                nextPosition.coordinates.x++</span>
        case S:<span class="cov8" title="1">
                nextPosition.coordinates.y--</span>
        case W:<span class="cov8" title="1">
                nextPosition.coordinates.x--</span>
        }
        <span class="cov8" title="1">return nextPosition</span>
}

// turnLeft causes the Rover to rotate 90 degrees on itself to the left
func (r *Rover) turnLeft() <span class="cov8" title="1">{
        if r.position.direction == N </span><span class="cov8" title="1">{
                r.position.direction = W
                return
        }</span>
        <span class="cov8" title="1">r.position.direction--</span>
}

// turnRight causes the Rover to rotate 90 degrees on itself to the right
func (r *Rover) turnRight() <span class="cov8" title="1">{
        if r.position.direction == W </span><span class="cov8" title="1">{
                r.position.direction = N
                return
        }</span>
        <span class="cov8" title="1">r.position.direction++</span>
}

// validateBoundaries is a helper used through the rest of the code. It takes a pointer to a Position and a pointer to a Plateau returning an error should the position be out of bounds for the given plateau
func validateBoundaries(pos *Position, plateau *Plateau) error <span class="cov8" title="1">{
        if pos.coordinates.x &lt; 0 || pos.coordinates.x &gt; plateau.maxX || pos.coordinates.y &lt; 0 || pos.coordinates.y &gt; plateau.maxY </span><span class="cov8" title="1">{
                return ErrPositionOutOfBounds
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validate is a helper that wraps validateBoundaries
func (pos *Position) validate(plateau *Plateau) error <span class="cov8" title="1">{
        return validateBoundaries(pos, plateau)
}</span>

// set updates the Position's coordinates and direction
func (p *Position) set(newPos Position) <span class="cov8" title="1">{
        p.coordinates.x = newPos.coordinates.x
        p.coordinates.y = newPos.coordinates.y
        p.direction = newPos.direction
}</span>

// NewPlateau returns a pointer to a new Plateau, validating against minimum dimensions and returning an error accordingly
func NewPlateau(maxX, maxY int) (*Plateau, error) <span class="cov8" title="1">{
        if maxX &lt; minPlateauX || maxY &lt; minPlateauY </span><span class="cov8" title="1">{
                return nil, ErrPlateauTooSmall
        }</span>

        <span class="cov8" title="1">return &amp;Plateau{
                maxX: maxX,
                maxY: maxY,
        }, nil</span>
}

// NewMissionControl takes a pointer to a Plateau struct and returns a pointer to a new MissionControl struct returning an error should the given Plateau be nil
func NewMissionControl(p *Plateau) (*MissionControl, error) <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return nil, ErrPlateauIsNil
        }</span>

        <span class="cov8" title="1">return &amp;MissionControl{
                plateau:         p,
                occupiedSquares: make(map[Coordinates]int),
        }, nil</span>
}

// validate takes a Position pointer and returns an error should the desired Position fail validation or if another rover is already at that Position
func (mc *MissionControl) validate(pos *Position) error <span class="cov8" title="1">{
        if err := validateBoundaries(pos, mc.plateau); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if _, ok := mc.occupiedSquares[pos.coordinates]; ok </span><span class="cov8" title="1">{
                return ErrRoverCollision
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RunRover takes a Rover pointer and a command string, returning a feedback string and an error should the commands fail. It keeps track of previous placed Rover in the Plateau and processes the commands giving feedback  to the user
func (mc *MissionControl) RunRover(r *Rover, commands string) (string, error) <span class="cov8" title="1">{
        // check to see if mission control is attempting to place a rover on a location that's occupied
        if err := mc.validate(r.position); err != nil </span><span class="cov8" title="1">{
                // original error remains wrapped
                return "", fmt.Errorf("new rover with id %d cannot be placed at (%s): %w", r.id, r.position.String(), err)
        }</span>

        // place an entry in the occupied map using x, y coordinates as key and rover id as the value
        <span class="cov8" title="1">mc.occupiedSquares[r.position.coordinates] = r.id

        // process commands
        for _, c := range commands </span><span class="cov8" title="1">{
                switch Command(c) </span>{
                case CmdLeft:<span class="cov8" title="1">
                        r.turnLeft()</span>
                case CmdRight:<span class="cov8" title="1">
                        r.turnRight()</span>
                case CmdMove:<span class="cov8" title="1">
                        // store current position before moving
                        currentPosKey := r.position.coordinates

                        nextPos := r.move()

                        // handle invalid moves
                        if err := mc.validate(&amp;nextPos); err != nil </span><span class="cov8" title="1">{
                                // this is an invalid move so it will be ignored and we carry on attempting remaining commands
                                log.Printf("WARN: Rover %d ignored move to (%v): %s", r.id, nextPos.String(), err.Error())
                                continue</span>
                        }

                        <span class="cov8" title="1">r.position.set(nextPos)

                        // delete existing state from the map after rover moves
                        delete(mc.occupiedSquares, currentPosKey)

                        // and update with new position here
                        mc.occupiedSquares[nextPos.coordinates] = r.id</span>
                }
        }

        <span class="cov8" title="1">return r.position.String(), nil</span>
}

// implement stringer interface so we can print a friendly direction when using a Print function
func (d Direction) String() string <span class="cov8" title="1">{
        switch d </span>{
        case N:<span class="cov8" title="1">
                return "N"</span>
        case E:<span class="cov8" title="1">
                return "E"</span>
        case S:<span class="cov8" title="1">
                return "S"</span>
        case W:<span class="cov8" title="1">
                return "W"</span>
        default:<span class="cov0" title="0">
                return "?"</span> // should never happen
        }
}

func (mc *MissionControl) Execute(input *MissionControlInput) ([]string, error) <span class="cov8" title="1">{
        var output []string

        for i, instruction := range input.Instructions </span><span class="cov8" title="1">{
                roverID := i + 1

                currentRover, err := NewRover(roverID, instruction.InitialPosition)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%w %d: %v", ErrRoverCreating, roverID, err)
                }</span>

                <span class="cov8" title="1">singleRoverOutput, err := mc.RunRover(currentRover, instruction.Commands)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%w %d: %v", ErrRoverInstructions, roverID, err)
                }</span>

                <span class="cov8" title="1">output = append(output, singleRoverOutput)</span>
        }

        <span class="cov8" title="1">return output, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
